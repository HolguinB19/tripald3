<?php

/**
 * Implements hook_menu().
 */
function tripald3_menu() {
  $items = array();

  $items['ajax/tripal/d3-json/relationships/%/%'] = array(
    'title' => 'JS Graph: Tree',
    'page callback' => 'tripald3_get_relationship_json',
    'page arguments' => array(4,5),
    'access arguments' => array('view tripald3 json'),
    'type' => MENU_CALLBACK
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function tripald3_theme($existing, $type, $theme, $path) {
  $items = array();

  $items['tripald3_stock_pedigree'] = array(
    'template' => 'tripal_stock_pedigree',
    'path' => $path.'/templates',
    'variables' => array('node' => NULL),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function tripald3_permission() {
  return array(
    'view tripald3 json' => array(
      'title' => t('View Tripal D3 JSON'),
      'description' => t('Required for anyone wanting to view a Tripal D3 diagram.'),
    ),
    'view tripald3 pedigree' => array(
      'title' => t('View Tripal D3 Pedigree'),
      'description' => t('Required to view the pedigree pane on stock pages.'),
    ),
  );
}

/**
 * Implements hook_node_view(). Acts on all content types.
 */
function tripald3_node_view($node, $view_mode, $langcode) {

  switch ($node->type) {
    case 'tripal_germplasm':
      if ($view_mode == 'full') {
        if(user_access('view tripald3 pedigree')) {
          $node->content['tripal_stock_pedigree'] = array(
            '#theme' => 'tripald3_stock_pedigree',
            '#node' => $node,
            '#tripal_toc_id'    => 'pedigree',
            '#tripal_toc_title' => 'Pedigree'
          );
        }
      }
    break;
  }
}

/**
 *
 */
function tripald3_preprocess_tripald3_stock_pedigree($vars) {

  $path = drupal_get_path('module', 'tripald3');
  $libpath = 'sites/all/libraries';
  drupal_add_js('http://d3js.org/d3.v3.js', 'external');

  drupal_add_js($path . '/js/bioD3.js');
  drupal_add_css($path . '/css/tripald3.css', array('group' => CSS_DEFAULT, 'type' => 'file'));

}

/**
 *
 */
function tripald3_get_relationship_json($base_table, $id) {

  drupal_add_http_header('Content-Type', 'application/json');
  drupal_add_http_header('Access-Control-Allow-Origin', "*");

  $relationships = tripald3_get_relationship_tree_data(
    $base_table,
    $id,
    array(
      'restrict relationships' => array(
        'object' => array(
          'is_maternal_parent_of', 'is_paternal_parent_of',
        ),
        'subject' => array(
          'is_registered_cultivar_of',
          'is_progeny_of_selfing_of',
          'is_selection_of'
        )
      ),
    )
  );

  //return '<pre>' . print_r($relationships, TRUE) . '</pre>';
  return drupal_json_output($relationships);
}

/**
 *
 * ASSUMPTION #1: In pedigree tree's the root is the child
 * without any children of it's own.
 */
function tripald3_get_relationship_tree_data($base_table, $id, $options = array(), $data = array()) {
  $rel_table = $base_table . '_relationship';
  $base_table_pkey = $base_table . '_id';

  // Get the root details if none were provided.
  $is_root = FALSE;
  if (empty($data)) {
    $is_root = TRUE;
    $root = chado_generate_var($base_table, array($base_table_pkey => $id));//chado_select_record($base_table, array('stock_id', 'name, uniquename'), array($base_table_pkey => $id));
    $root = chado_expand_var($root, 'node','stock');
    $data = array(
      'current' => $root->stock,
      'parent' => array('stock_id' => "null", 'name' => "null"),
      'children' => array(),
    );
    $data['current']->nid = $root->nid;
    $data['popover'] = tripald3_stock_pedigree_popover_content($data['current']);
  }

  // Base Case: there are no additional relationships.
  if (!isset($data['children'])) {
    $data['children'] = array();
  }

  // Retrieve relationships where the passed in record is the object.
  $sql = 'SELECT
            r.subject_id,
            r.type_id,
            cvt.name as type,
            r.object_id
          FROM {' . $rel_table . '} r
          LEFT JOIN {cvterm} cvt ON cvt.cvterm_id=r.type_id
          WHERE ';
  if (isset($options['restrict relationships'])) {
    $where = array();
    if (isset($options['restrict relationships']['subject'])) {
      $where[] = "(r.object_id = :id AND cvt.name IN ('" . implode("', '", $options['restrict relationships']['object']) . "'))";
    }
    if (isset($options['restrict relationships']['object'])) {
      $where[] = "(r.subject_id = :id AND cvt.name IN ('" . implode("', '", $options['restrict relationships']['subject']) . "'))";
    }
  }
  else {
    $where[] = 'r.object_id=:id AND r.subject_id=:id';
  }
  $sql = $sql . implode(' OR ', $where) . ' ORDER BY cvt.name ASC';
  $rels = chado_query($sql , array(':id' => $id));

  foreach($rels as $rel) {

    // If we are dealing with a subject rooted relationship:
    if ($rel->subject_id == $id) {

      $child = chado_generate_var($base_table, array('stock_id' => $rel->object_id));
      $child = chado_expand_var($child, 'node','stock');

      if (isset($child->nid)) {
        $stock = $child->stock;
        $stock->nid = $child->nid;
      }
      else {
        $stock = $child;
      }

      $subnode = array(
        'current' => $stock,
        'parent' => array(
          'parent_id' => $rel->subject_id,
          'name' => '',
        ),
        'relationship' => $rel,
        'children' => array()
      );
      $subnode['relationship']->object = $child->name;
      $subnode['relationship']->subject = $data['current']->name;

      $subnode['popover'] = tripald3_stock_pedigree_popover_content($subnode['current']);

      // Now recursively add children.
      // NOTE: since we support folloing relationships from both directions
      // we need to be careful how we which id we recursively follow to ensure
      // we don't end up in an endless loop.
      $data['children'][] = tripald3_get_relationship_tree_data(
        $base_table,
        $rel->object_id,
        $options,
        $subnode
      );

    // Otherwise we're dealing with an object rooted relationship:
    } else {

      $child = chado_generate_var($base_table, array('stock_id' => $rel->subject_id));

      if (isset($child->nid)) {
        $stock = $child->stock;
        $stock->nid = $child->nid;
      }
      else {
        $stock = $child;
      }

      $subnode = array(
        'current' => $stock,
        'parent' => array(
          'parent_id' => $rel->object_id,
          'name' => '',
        ),
        'relationship' => $rel,
        'children' => array()
      );
      $subnode['relationship']->subject = $child->name;
      $subnode['relationship']->object = $data['current']->name;

      $subnode['popover'] = tripald3_stock_pedigree_popover_content($subnode['current']);

      // Now recursively add children.
      // NOTE: since we support folloing relationships from both directions
      // we need to be careful how we which id we recursively follow to ensure
      // we don't end up in an endless loop.
      $data['children'][] = tripald3_get_relationship_tree_data(
        $base_table,
        $rel->subject_id,
        $options,
        $subnode
      );
    }
  }

  // D3 assumes the first level will be an array of roots,
  // so we need to make that happen if we're at the root.
  if ($is_root) {
    $data = array(
      $data
    );
  }

  return $data;
}